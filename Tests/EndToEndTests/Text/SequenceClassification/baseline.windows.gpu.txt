CPU info:
    CPU Model Name: Intel(R) Xeon(R) CPU W3565 @ 3.20GHz
    Hardware threads: 8
    Total Memory: 12580436 kB
-------------------------------------------------------------------
=== Running /cygdrive/c/jenkins/workspace/CNTK-Test-Windows-W1/x64/debug/cntk.exe configFile=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config/seqcla.cntk currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu DeviceId=0 timestamping=true
-------------------------------------------------------------------
Build info: 

		Built time: Jul 14 2016 05:11:35
		Last modified date: Thu Jul 14 03:20:47 2016
		Build type: Debug
		Build target: GPU
		With 1bit-SGD: no
		Math lib: mkl
		CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.5
		CUB_PATH: C:\src\cub-1.4.1
		CUDNN_PATH: c:\NVIDIA\cudnn-4.0\cuda
		Build Branch: HEAD
		Build SHA1: 72bee394bf461e8f6f0feb593a8416c05f481957
		Built by svcphil on liana-08-w
		Build Path: c:\jenkins\workspace\CNTK-Build-Windows\Source\CNTK\
-------------------------------------------------------------------
Changed current directory to C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
07/14/2016 06:31:09: -------------------------------------------------------------------
07/14/2016 06:31:09: Build info: 

07/14/2016 06:31:09: 		Built time: Jul 14 2016 05:11:35
07/14/2016 06:31:09: 		Last modified date: Thu Jul 14 03:20:47 2016
07/14/2016 06:31:09: 		Build type: Debug
07/14/2016 06:31:09: 		Build target: GPU
07/14/2016 06:31:09: 		With 1bit-SGD: no
07/14/2016 06:31:09: 		Math lib: mkl
07/14/2016 06:31:09: 		CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.5
07/14/2016 06:31:09: 		CUB_PATH: C:\src\cub-1.4.1
07/14/2016 06:31:09: 		CUDNN_PATH: c:\NVIDIA\cudnn-4.0\cuda
07/14/2016 06:31:09: 		Build Branch: HEAD
07/14/2016 06:31:09: 		Build SHA1: 72bee394bf461e8f6f0feb593a8416c05f481957
07/14/2016 06:31:09: 		Built by svcphil on liana-08-w
07/14/2016 06:31:09: 		Build Path: c:\jenkins\workspace\CNTK-Build-Windows\Source\CNTK\
07/14/2016 06:31:09: -------------------------------------------------------------------
07/14/2016 06:31:09: -------------------------------------------------------------------
07/14/2016 06:31:09: GPU info:

07/14/2016 06:31:09: 		Device[0]: cores = 2496; computeCapability = 5.2; type = "Quadro M4000"; memory = 8192 MB
07/14/2016 06:31:09: -------------------------------------------------------------------

07/14/2016 06:31:09: Running on cntk-muc01 at 2016/07/14 06:31:09
07/14/2016 06:31:09: Command line: 
C:\jenkins\workspace\CNTK-Test-Windows-W1\x64\debug\cntk.exe  configFile=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config/seqcla.cntk  currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data  RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu  DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data  ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config  OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu  DeviceId=0  timestamping=true



07/14/2016 06:31:09: >>>>>>>>>>>>>>>>>>>> RAW CONFIG (VARIABLES NOT RESOLVED) >>>>>>>>>>>>>>>>>>>>
07/14/2016 06:31:09: RootDir = ".."
ConfigDir = "$RootDir$/Config"
DataDir   = "$RootDir$/Data"
OutputDir = "$RootDir$/Output"
ModelDir  = "$OutputDir$/Models"
command=Train 
deviceId = $DeviceId$
modelPath="$ModelDir$/seqcla.dnn"
Train=[
    action="train"
    run=BrainScriptNetworkBuilder
    BrainScriptNetworkBuilder=[
        Layers = [
            EmbeddingLayer(input, vocabSize, embeddingDim, embeddingPath) = [
                embedding = Transpose(LearnableParameter(vocabSize, embeddingDim, learningRateMultiplier = 0.0, init = 'fromFile', initFromFilePath = embeddingPath))          
                lookup = GatherPacked(features, embedding)
            ].lookup
            DenseLayer(input, inputSize, outputSize, activation) = [
               z = BFF(input, outputSize, inputSize).z
               act = activation(z)
            ].act
            LSTMLayer (input, inputSize, outputSize, cellSize, selector) = [ 
               lstm = BS.RNNs.RecurrentLSTMP (outputSize, cellDim=cellSize, input, inputDim=inputSize).h
               result = selector(lstm)
            ].result
        ]        
        // LSTM params
        lstmDim = 25
        cellDim = 25
        // model
        numLabels = 5        
        vocab = 2000
        embedDim = 50        
        // set up features and labels
        t = DynamicAxis()
features = Input(1, dynamicAxis=t)   
labels   = Input(numLabels)          
        // load the pre-learned word embedding matrix
        l1 = Layers.EmbeddingLayer(features, vocab, embedDim, 'embeddingmatrix.txt')
        l2 = Layers.LSTMLayer(l1, embedDim, lstmDim, cellDim, BS.Sequences.Last)
        l3 = Layers.DenseLayer(l2, lstmDim, numLabels, Pass)
        out = Pass(l3, tag='output')   
        // Make sure the trainer understands that the time dimension of l3 is actually the same as that of labels.
        l3p = ReconcileDynamicAxis(l3, labels)
        // training criteria
        ce  = CrossEntropyWithSoftmax(labels, l3p, tag='criterion')   // this is the training objective
        err = ErrorPrediction        (labels, l3p, tag='evaluation')  // this also gets tracked
    ]
    SGD = [	
        epochSize = 0
        minibatchSize = 200
        maxEpochs = 5
        momentumPerMB = 0.9
        learningRatesPerMB = 0.1
        keepCheckPointFiles = true
    ]
    reader = [
        readerType = "CNTKTextFormatReader"
        file = "$DataDir$/Train.txt"            
        input = [            
            features=[
                alias = "x"                
                dim = 1               
                format = "dense"
            ]
            labels=[
                alias = "y"                
                dim = 5           
                format = "dense"
            ]
        ]
   ]    
outputPath = "$OutputDir$/output.txt"        
]
Write=[
    action="test"
    run=BrainScriptNetworkBuilder
    format = [
      sequencePrologue=%d\t|w.shape %x\n%d\t|w\s
      sampleSeparator=\n%d\t|w\s
      elementSeparator=\s
    ]
    modelFile = "$ModelDir$/seqcla.dnn"    
    reader = [
            readerType = "CNTKTextFormatReader"
            file = "$DataDir$/Train.txt"            
            input = [            
                features=[
                    alias = "x"                
                    dim = 1               
                    format = "dense"
                ]
                labels=[
                    alias = "y"                
                    dim = 5           
                    format = "dense"
                ]
            ]
   ]    
outputPath = "$OutputDir$/output.txt"        
]
currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config
OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DeviceId=0
timestamping=true

07/14/2016 06:31:09: <<<<<<<<<<<<<<<<<<<< RAW CONFIG (VARIABLES NOT RESOLVED)  <<<<<<<<<<<<<<<<<<<<

07/14/2016 06:31:09: >>>>>>>>>>>>>>>>>>>> RAW CONFIG WITH ALL VARIABLES RESOLVED >>>>>>>>>>>>>>>>>>>>
07/14/2016 06:31:09: RootDir = ".."
ConfigDir = "../Config"
DataDir   = "../Data"
OutputDir = "../Output"
ModelDir  = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models"
command=Train 
deviceId = 0
modelPath="C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn"
Train=[
    action="train"
    run=BrainScriptNetworkBuilder
    BrainScriptNetworkBuilder=[
        Layers = [
            EmbeddingLayer(input, vocabSize, embeddingDim, embeddingPath) = [
                embedding = Transpose(LearnableParameter(vocabSize, embeddingDim, learningRateMultiplier = 0.0, init = 'fromFile', initFromFilePath = embeddingPath))          
                lookup = GatherPacked(features, embedding)
            ].lookup
            DenseLayer(input, inputSize, outputSize, activation) = [
               z = BFF(input, outputSize, inputSize).z
               act = activation(z)
            ].act
            LSTMLayer (input, inputSize, outputSize, cellSize, selector) = [ 
               lstm = BS.RNNs.RecurrentLSTMP (outputSize, cellDim=cellSize, input, inputDim=inputSize).h
               result = selector(lstm)
            ].result
        ]        
        // LSTM params
        lstmDim = 25
        cellDim = 25
        // model
        numLabels = 5        
        vocab = 2000
        embedDim = 50        
        // set up features and labels
        t = DynamicAxis()
features = Input(1, dynamicAxis=t)   
labels   = Input(numLabels)          
        // load the pre-learned word embedding matrix
        l1 = Layers.EmbeddingLayer(features, vocab, embedDim, 'embeddingmatrix.txt')
        l2 = Layers.LSTMLayer(l1, embedDim, lstmDim, cellDim, BS.Sequences.Last)
        l3 = Layers.DenseLayer(l2, lstmDim, numLabels, Pass)
        out = Pass(l3, tag='output')   
        // Make sure the trainer understands that the time dimension of l3 is actually the same as that of labels.
        l3p = ReconcileDynamicAxis(l3, labels)
        // training criteria
        ce  = CrossEntropyWithSoftmax(labels, l3p, tag='criterion')   // this is the training objective
        err = ErrorPrediction        (labels, l3p, tag='evaluation')  // this also gets tracked
    ]
    SGD = [	
        epochSize = 0
        minibatchSize = 200
        maxEpochs = 5
        momentumPerMB = 0.9
        learningRatesPerMB = 0.1
        keepCheckPointFiles = true
    ]
    reader = [
        readerType = "CNTKTextFormatReader"
        file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
        input = [            
            features=[
                alias = "x"                
                dim = 1               
                format = "dense"
            ]
            labels=[
                alias = "y"                
                dim = 5           
                format = "dense"
            ]
        ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]
Write=[
    action="test"
    run=BrainScriptNetworkBuilder
    format = [
      sequencePrologue=%d\t|w.shape %x\n%d\t|w\s
      sampleSeparator=\n%d\t|w\s
      elementSeparator=\s
    ]
    modelFile = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn"    
    reader = [
            readerType = "CNTKTextFormatReader"
            file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
            input = [            
                features=[
                    alias = "x"                
                    dim = 1               
                    format = "dense"
                ]
                labels=[
                    alias = "y"                
                    dim = 5           
                    format = "dense"
                ]
            ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]
currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config
OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DeviceId=0
timestamping=true

07/14/2016 06:31:09: <<<<<<<<<<<<<<<<<<<< RAW CONFIG WITH ALL VARIABLES RESOLVED <<<<<<<<<<<<<<<<<<<<

07/14/2016 06:31:09: >>>>>>>>>>>>>>>>>>>> PROCESSED CONFIG WITH ALL VARIABLES RESOLVED >>>>>>>>>>>>>>>>>>>>
configparameters: seqcla.cntk:command=Train
configparameters: seqcla.cntk:ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config
configparameters: seqcla.cntk:currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
configparameters: seqcla.cntk:DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
configparameters: seqcla.cntk:deviceId=0
configparameters: seqcla.cntk:ModelDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models
configparameters: seqcla.cntk:modelPath=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn
configparameters: seqcla.cntk:OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
configparameters: seqcla.cntk:RootDir=..
configparameters: seqcla.cntk:RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
configparameters: seqcla.cntk:timestamping=true
configparameters: seqcla.cntk:Train=[
    action="train"
    run=BrainScriptNetworkBuilder
    BrainScriptNetworkBuilder=[
        Layers = [
            EmbeddingLayer(input, vocabSize, embeddingDim, embeddingPath) = [
                embedding = Transpose(LearnableParameter(vocabSize, embeddingDim, learningRateMultiplier = 0.0, init = 'fromFile', initFromFilePath = embeddingPath))          
                lookup = GatherPacked(features, embedding)
            ].lookup
            DenseLayer(input, inputSize, outputSize, activation) = [
               z = BFF(input, outputSize, inputSize).z
               act = activation(z)
            ].act
            LSTMLayer (input, inputSize, outputSize, cellSize, selector) = [ 
               lstm = BS.RNNs.RecurrentLSTMP (outputSize, cellDim=cellSize, input, inputDim=inputSize).h
               result = selector(lstm)
            ].result
        ]        
        // LSTM params
        lstmDim = 25
        cellDim = 25
        // model
        numLabels = 5        
        vocab = 2000
        embedDim = 50        
        // set up features and labels
        t = DynamicAxis()
features = Input(1, dynamicAxis=t)   
labels   = Input(numLabels)          
        // load the pre-learned word embedding matrix
        l1 = Layers.EmbeddingLayer(features, vocab, embedDim, 'embeddingmatrix.txt')
        l2 = Layers.LSTMLayer(l1, embedDim, lstmDim, cellDim, BS.Sequences.Last)
        l3 = Layers.DenseLayer(l2, lstmDim, numLabels, Pass)
        out = Pass(l3, tag='output')   
        // Make sure the trainer understands that the time dimension of l3 is actually the same as that of labels.
        l3p = ReconcileDynamicAxis(l3, labels)
        // training criteria
        ce  = CrossEntropyWithSoftmax(labels, l3p, tag='criterion')   // this is the training objective
        err = ErrorPrediction        (labels, l3p, tag='evaluation')  // this also gets tracked
    ]
    SGD = [	
        epochSize = 0
        minibatchSize = 200
        maxEpochs = 5
        momentumPerMB = 0.9
        learningRatesPerMB = 0.1
        keepCheckPointFiles = true
    ]
    reader = [
        readerType = "CNTKTextFormatReader"
        file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
        input = [            
            features=[
                alias = "x"                
                dim = 1               
                format = "dense"
            ]
            labels=[
                alias = "y"                
                dim = 5           
                format = "dense"
            ]
        ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]

configparameters: seqcla.cntk:Write=[
    action="test"
    run=BrainScriptNetworkBuilder
    format = [
      sequencePrologue=%d\t|w.shape %x\n%d\t|w\s
      sampleSeparator=\n%d\t|w\s
      elementSeparator=\s
    ]
    modelFile = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn"    
    reader = [
            readerType = "CNTKTextFormatReader"
            file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
            input = [            
                features=[
                    alias = "x"                
                    dim = 1               
                    format = "dense"
                ]
                labels=[
                    alias = "y"                
                    dim = 5           
                    format = "dense"
                ]
            ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]

07/14/2016 06:31:09: <<<<<<<<<<<<<<<<<<<< PROCESSED CONFIG WITH ALL VARIABLES RESOLVED <<<<<<<<<<<<<<<<<<<<
07/14/2016 06:31:09: Commands: Train
07/14/2016 06:31:09: Precision = "float"
07/14/2016 06:31:09: CNTKModelPath: C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn
07/14/2016 06:31:09: CNTKCommandTrainInfo: Train : 5
07/14/2016 06:31:09: CNTKCommandTrainInfo: CNTKNoMoreCommands_Total : 5

07/14/2016 06:31:09: ##############################################################################
07/14/2016 06:31:09: #                                                                            #
07/14/2016 06:31:09: # Action "train"                                                             #
07/14/2016 06:31:09: #                                                                            #
07/14/2016 06:31:09: ##############################################################################

07/14/2016 06:31:09: CNTKCommandTrainBegin: Train

07/14/2016 06:31:10: Creating virgin network.

Post-processing network...

4 roots:
	ce = CrossEntropyWithSoftmax()
	err = ErrorPrediction()
	out = Pass()
	t = DynamicAxis()

Loop[0] --> Loop_l2.lstm.lstmState._privateInnards.ht -> 25 nodes

	l2.lstm.prevState.h	l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1]	l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0]
	l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1]	l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0]	l2.lstm.prevState.c
	l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1]	l2.lstm.lstmState._privateInnards.ft._	l2.lstm.lstmState._privateInnards.ft
	l2.lstm.lstmState._privateInnards.bft	l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1]	l2.lstm.lstmState._privateInnards.it._.PlusArgs[0]
	l2.lstm.lstmState._privateInnards.it._.PlusArgs[1]	l2.lstm.lstmState._privateInnards.it._	l2.lstm.lstmState._privateInnards.it
	l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1]	l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z	l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1]
	l2.lstm.lstmState._privateInnards.bit	l2.lstm.lstmState._privateInnards.ct	l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1]
	l2.lstm.lstmState._privateInnards.ot._	l2.lstm.lstmState._privateInnards.ot	l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1]
	l2.lstm.lstmState._privateInnards.ht

Validating network. 71 nodes to process in pass 1.

Validating --> labels = InputValue() :  -> [5 x *]
Validating --> l3.z.W = LearnableParameter() :  -> [5 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> features = InputValue() :  -> [1 x t]
Validating --> l1.embedding.x = LearnableParameter() :  -> [2000 x 50]
Validating --> l1.embedding = TransposeDimensions (l1.embedding.x) : [2000 x 50] -> [50 x 2000]
Validating --> l1.lookup = GatherPacked (features, l1.embedding) : [1 x t], [50 x 2000] -> [50 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1]) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1]) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1]) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1]) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [0] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1]) : [25 x t], [25] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [0] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1]) : [25 x t], [25] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [0] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._ = Plus (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0], l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1]) : [25 x t], [25] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft = Sigmoid (l2.lstm.lstmState._privateInnards.ft._) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bft = ElementTimes (l2.lstm.lstmState._privateInnards.ft, l2.lstm.prevState.c) : [25 x t], [0] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [0] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1]) : [25 x t], [25] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [0] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._ = Plus (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0], l2.lstm.lstmState._privateInnards.it._.PlusArgs[1]) : [25 x t], [25] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it = Sigmoid (l2.lstm.lstmState._privateInnards.it._) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [0] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z = Plus (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0], l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1]) : [25 x t], [25] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1] = Tanh (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bit = ElementTimes (l2.lstm.lstmState._privateInnards.it, l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1]) : [25 x t], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ct = Plus (l2.lstm.lstmState._privateInnards.bft, l2.lstm.lstmState._privateInnards.bit) : [25 x t], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.lstmState._privateInnards.ct) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot._ = Plus (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0], l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1]) : [25 x t], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot = Sigmoid (l2.lstm.lstmState._privateInnards.ot._) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1] = Tanh (l2.lstm.lstmState._privateInnards.ct) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ht = ElementTimes (l2.lstm.lstmState._privateInnards.ot, l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1]) : [25 x t], [25 x t] -> [25 x t]
Validating --> l2.result.beginFlags.input.z.ElementTimesArgs[0] = Slice (l2.lstm.lstmState._privateInnards.ht) : [25 x t] -> [1 x t]
Validating --> BS.Constants.Zero = LearnableParameter() :  -> [1]
Validating --> l2.result.beginFlags.input.z = ElementTimes (l2.result.beginFlags.input.z.ElementTimesArgs[0], BS.Constants.Zero) : [1 x t], [1] -> [1 x t]
Validating --> l2.result.beginFlags.input = SumColumnElements (l2.result.beginFlags.input.z) : [1 x t] -> [1 x t]
Validating --> l2.result.beginFlags = FutureValue (l2.result.beginFlags.input) : [1 x t] -> [1 x t]
Validating --> l2.result.out.indexSequence.indexSequence = Where (l2.result.beginFlags) : [1 x t] -> [1 x WhereNodeAxis]
Validating --> l2.result.out.indexSequence = PackedIndex (l2.lstm.lstmState._privateInnards.ht, l2.result.out.indexSequence.indexSequence) : [25 x t], [1 x WhereNodeAxis] -> [1 x WhereNodeAxis]
Validating --> l2.result.out = GatherPacked (l2.result.out.indexSequence, l2.lstm.lstmState._privateInnards.ht) : [1 x WhereNodeAxis], [25 x t] -> [25 x WhereNodeAxis]
Validating --> l3.z.z.PlusArgs[0] = Times (l3.z.W, l2.result.out) : [5 x 25], [25 x WhereNodeAxis] -> [5 x WhereNodeAxis]
Validating --> l3.z.B = LearnableParameter() :  -> [5 x 1]
Validating --> l3.z.z = Plus (l3.z.z.PlusArgs[0], l3.z.B) : [5 x WhereNodeAxis], [5 x 1] -> [5 x 1 x WhereNodeAxis]
Validating --> l3.act = Pass (l3.z.z) : [5 x 1 x WhereNodeAxis] -> [5 x 1 x WhereNodeAxis]
Validating --> l3p = ReconcileDynamicAxis (l3.act, labels) : [5 x 1 x WhereNodeAxis], [5 x *] -> [5 x 1 x *]
Validating --> ce = CrossEntropyWithSoftmax (labels, l3p) : [5 x *], [5 x 1 x *] -> [1]
Validating --> err = ErrorPrediction (labels, l3p) : [5 x *], [5 x 1 x *] -> [1]
Validating --> out = Pass (l3.act) : [5 x 1 x WhereNodeAxis] -> [5 x 1 x WhereNodeAxis]
Validating --> t = DynamicAxis() :  -> [1 x 1 x t]

Validating network. 49 nodes to process in pass 2.

Validating --> l2.lstm.prevState.h = PastValue (l2.lstm.lstmState._privateInnards.ht) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t] -> [25 x t]
Validating --> l2.lstm.prevState.c = PastValue (l2.lstm.lstmState._privateInnards.ct) : [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [25 x t] -> [25 x t]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t] -> [25 x t]

Validating network. 8 nodes to process in pass 3.


Validating network, final pass.



69 out of 71 nodes do not share the minibatch layout with the input data.

Post-processing network complete.

07/14/2016 06:31:12: Created model with 71 nodes on GPU 0.

07/14/2016 06:31:12: Training criterion node(s):
07/14/2016 06:31:12: 	ce = CrossEntropyWithSoftmax

07/14/2016 06:31:12: Evaluation criterion node(s):

07/14/2016 06:31:12: 	err = ErrorPrediction


Allocating matrices for forward and/or backward propagation.

Memory Sharing Structure:

0000000000000000: {[BS.Constants.Zero Gradient[1]] [err Gradient[1]] [features Gradient[1 x t]] [l1.embedding Gradient[50 x 2000]] [l1.embedding.x Gradient[2000 x 50]] [l1.lookup Gradient[50 x t]] [labels Gradient[5 x *]] [out Gradient[5 x 1 x WhereNodeAxis]] [t Gradient[1 x 1 x t]] [t Value[1 x 1 x t]] }
0000008C9628D0D0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000008C9628D270: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000008C9628D340: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000008C9628D410: {[l2.lstm.lstmState._privateInnards.ot._ Gradient[25 x t]] [l2.result.beginFlags Value[1 x t]] [l2.result.beginFlags.input.z Gradient[1 x t]] }
0000008C9628D4E0: {[out Value[5 x 1 x WhereNodeAxis]] }
0000008C9628D5B0: {[ce Value[1]] }
0000008C9628D680: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0] Value[25 x t]] [l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000008C9628D750: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Value[25 x t]] [l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Gradient[25]] }
0000008C9628D820: {[l1.lookup Value[50 x t]] }
0000008C9628D8F0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0] Value[25 x t]] [l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000008C9628DA90: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0] Value[25]] }
0000008C9628DC30: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0] Value[25]] }
0000008C9628DD00: {[l2.lstm.prevState.c Value[25 x t]] }
0000008C9628DDD0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0] Value[25 x t]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000008C9628DEA0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Value[25 x t]] }
0000008C9628DF70: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] Value[25 x t]] }
0000008C9628E040: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Gradient[25]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Value[25 x t]] }
0000008C9628E110: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0] Value[25 x t]] }
0000008C9628E1E0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0] Value[25 x t]] }
0000008C9628E380: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] Value[25 x t]] }
0000008C9628E450: {[l1.embedding Value[50 x 2000]] }
0000008C9628E520: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] Value[25 x t]] }
0000008C9628E5F0: {[l2.lstm.lstmState._privateInnards.ft._ Value[25 x t]] }
0000008C9628E6C0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0] Value[25 x t]] [l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000008C9628E790: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1] Value[25 x t]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Gradient[25]] }
0000008C9628E860: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Value[25]] }
0000008C9628EA00: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000008C9628EAD0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Value[25]] }
0000008C9628EBA0: {[l2.result.out.indexSequence.indexSequence Value[1 x WhereNodeAxis]] }
0000008C9628EC70: {[BS.Constants.Zero Value[1]] }
0000008C9628EE10: {[l3.z.B Value[5 x 1]] }
0000008C9628EEE0: {[err Value[1]] }
0000008C9629D110: {[l2.lstm.lstmState._privateInnards.ht Gradient[25 x t]] [l3.act Value[5 x 1 x WhereNodeAxis]] [l3.z.z.PlusArgs[0] Gradient[5 x WhereNodeAxis]] }
0000008C9629D1E0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000008C9629D2B0: {[l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1] Gradient[25 x t]] [l2.result.beginFlags.input Value[1 x t]] [l2.result.beginFlags.input.z.ElementTimesArgs[0] Gradient[1 x t]] }
0000008C9629D380: {[l3.act Gradient[5 x 1 x WhereNodeAxis]] [l3.z.B Gradient[5 x 1]] }
0000008C9629D520: {[l2.lstm.lstmState._privateInnards.it._ Gradient[25 x t]] }
0000008C9629D6C0: {[l2.lstm.lstmState._privateInnards.it Gradient[25 x t]] }
0000008C9629D790: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] Value[25 x t]] }
0000008C9629D860: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1] Value[25 x t]] }
0000008C9629D930: {[l2.lstm.lstmState._privateInnards.ot Value[25 x t]] }
0000008C9629DA00: {[l2.lstm.lstmState._privateInnards.ct Value[25 x t]] }
0000008C9629DAD0: {[l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1] Value[25 x t]] }
0000008C9629DBA0: {[l2.lstm.lstmState._privateInnards.ct Gradient[25 x t]] [l2.result.beginFlags.input.z Value[1 x t]] }
0000008C9629DC70: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0] Gradient[25 x t]] }
0000008C9629DD40: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] Gradient[25 x t]] }
0000008C9629DE10: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1] Gradient[25 x t]] [l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Gradient[25 x t]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Gradient[25 x t]] [l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Gradient[25 x t]] [l2.lstm.prevState.h Gradient[25 x t]] }
0000008C9629DEE0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0] Gradient[25 x t]] }
0000008C9629E080: {[l2.lstm.lstmState._privateInnards.bft Gradient[25 x t]] [l3p Gradient[5 x 1 x *]] }
0000008C9629E150: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] Gradient[25 x t]] }
0000008C9629E220: {[l2.lstm.lstmState._privateInnards.bit Value[25 x t]] }
0000008C9629E2F0: {[l2.lstm.lstmState._privateInnards.ot._ Value[25 x t]] }
0000008C9629E3C0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0] Gradient[25 x t]] [l2.result.beginFlags.input Gradient[1 x t]] [l2.result.out Value[25 x WhereNodeAxis]] [l2.result.out.indexSequence.indexSequence Gradient[1 x WhereNodeAxis]] }
0000008C9629E490: {[l3.z.W Gradient[5 x 25]] [l3.z.z Value[5 x 1 x WhereNodeAxis]] }
0000008C9629E560: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0] Gradient[25]] [l2.result.out Gradient[25 x WhereNodeAxis]] [l3.z.z Gradient[5 x 1 x WhereNodeAxis]] [l3p Value[5 x 1 x *]] }
0000008C9629E630: {[l2.lstm.lstmState._privateInnards.it Value[25 x t]] }
0000008C9629E700: {[ce Gradient[1]] }
0000008C9629E8A0: {[l2.lstm.lstmState._privateInnards.bit Gradient[25 x t]] }
0000008C9629E970: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1] Gradient[25 x t]] }
0000008C9629EA40: {[l2.lstm.lstmState._privateInnards.ht Value[25 x t]] }
0000008C9629EBE0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z Gradient[25 x t]] }
0000008C9629ED80: {[l2.lstm.lstmState._privateInnards.ot Gradient[25 x t]] [l2.result.beginFlags.input.z.ElementTimesArgs[0] Value[1 x t]] }
0000008C9629EE50: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z Value[25 x t]] }
0000008C9629EF20: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1] Gradient[25 x t]] [l2.result.beginFlags Gradient[1 x t]] [l2.result.out.indexSequence Gradient[1 x WhereNodeAxis]] [l3.z.z.PlusArgs[0] Value[5 x WhereNodeAxis]] }
0000008C9629EFF0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1] Value[25 x t]] }
0000008C9630DA90: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0] Gradient[25]] }
0000008C9630DDD0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0] Gradient[25 x t]] }
0000008C9630DEA0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000008C9630DF70: {[l2.lstm.lstmState._privateInnards.ft Gradient[25 x t]] }
0000008C9630E040: {[l2.lstm.lstmState._privateInnards.ft._ Gradient[25 x t]] }
0000008C9630E110: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000008C9630E1E0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] Gradient[25 x t]] }
0000008C9630E2B0: {[l2.lstm.prevState.c Gradient[25 x t]] }
0000008C9630E380: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] Gradient[25 x t]] }
0000008C9630ED40: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0] Gradient[25 x t]] }
0000008C9630EE10: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0] Gradient[25]] }
0000008C9630EFB0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0] Gradient[25 x t]] }
0000008C9630F080: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] Gradient[25 x t]] }
0000008C9630F150: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0] Gradient[25 x t]] }
0000008C9630F220: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] Gradient[25 x t]] }
0000008C9630F630: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000008C99F6D960: {[labels Value[5 x *]] }
0000008C9A618970: {[l2.result.out.indexSequence Value[1 x WhereNodeAxis]] }
0000008C9A618B10: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000008C9A618BE0: {[l3.z.W Value[5 x 25]] }
0000008C9A618CB0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000008C9A618F20: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0] Gradient[25]] [l2.lstm.prevState.h Value[25 x t]] }
0000008C9A618FF0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000008C9A6190C0: {[l2.lstm.lstmState._privateInnards.ft Value[25 x t]] }
0000008C9A619260: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0] Value[25]] }
0000008C9A619330: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000008C9A619740: {[l1.embedding.x Value[2000 x 50]] }
0000008C9A619810: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0] Value[25]] }
0000008C9A6199B0: {[l2.lstm.lstmState._privateInnards.bft Value[25 x t]] }
0000008C9A619A80: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0] Value[25 x t]] }
0000008C9A619F60: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Value[25]] }
0000008C9A61A100: {[features Value[1 x t]] }
0000008C9A61A1D0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] Value[25 x t]] }
0000008C9A61A2A0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] Value[25 x t]] }
0000008C9A61A370: {[l2.lstm.lstmState._privateInnards.it._ Value[25 x t]] }

07/14/2016 06:31:12: No PreCompute nodes found, skipping PreCompute step.

07/14/2016 06:31:12: Starting Epoch 1: learning rate per sample = 0.000500  effective momentum = 0.900000  momentum as time constant = 1898.2 samples
BlockRandomizer::StartEpoch: epoch 0: frames [0..5433] (first sequence at sample 0), data subset 0 of 1

07/14/2016 06:31:12: Starting minibatch loop.
WARNING: The same matrix with dim [1, 47] has been transferred between different devices for 20 times.
07/14/2016 06:31:16: Finished Epoch[ 1 of 5]: [Training] ce = 1.58162725 * 1247; err = 0.48596632 * 1247; totalSamplesSeen = 1247; learningRatePerSample = 0.00050000002; epochTime=3.2532s
07/14/2016 06:31:16: SGD: Saving checkpoint model 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn.1'

07/14/2016 06:31:16: Starting Epoch 2: learning rate per sample = 0.000500  effective momentum = 0.900000  momentum as time constant = 1898.2 samples
BlockRandomizer::StartEpoch: epoch 1: frames [5433..10866] (first sequence at sample 5433), data subset 0 of 1

07/14/2016 06:31:16: Starting minibatch loop.
07/14/2016 06:31:19: Finished Epoch[ 2 of 5]: [Training] ce = 1.49505924 * 1247; err = 0.44667201 * 1247; totalSamplesSeen = 2494; learningRatePerSample = 0.00050000002; epochTime=2.9161s
07/14/2016 06:31:19: SGD: Saving checkpoint model 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn.2'

07/14/2016 06:31:19: Starting Epoch 3: learning rate per sample = 0.000500  effective momentum = 0.900000  momentum as time constant = 1898.2 samples
BlockRandomizer::StartEpoch: epoch 2: frames [10866..16299] (first sequence at sample 10866), data subset 0 of 1

07/14/2016 06:31:19: Starting minibatch loop.
07/14/2016 06:31:22: Finished Epoch[ 3 of 5]: [Training] ce = 1.42226891 * 1247; err = 0.44667201 * 1247; totalSamplesSeen = 3741; learningRatePerSample = 0.00050000002; epochTime=2.92017s
07/14/2016 06:31:22: SGD: Saving checkpoint model 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn.3'

07/14/2016 06:31:22: Starting Epoch 4: learning rate per sample = 0.000500  effective momentum = 0.900000  momentum as time constant = 1898.2 samples
BlockRandomizer::StartEpoch: epoch 3: frames [16299..21732] (first sequence at sample 16299), data subset 0 of 1

07/14/2016 06:31:22: Starting minibatch loop.
07/14/2016 06:31:25: Finished Epoch[ 4 of 5]: [Training] ce = 1.36981823 * 1247; err = 0.44667201 * 1247; totalSamplesSeen = 4988; learningRatePerSample = 0.00050000002; epochTime=2.90645s
07/14/2016 06:31:25: SGD: Saving checkpoint model 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn.4'

07/14/2016 06:31:25: Starting Epoch 5: learning rate per sample = 0.000500  effective momentum = 0.900000  momentum as time constant = 1898.2 samples
BlockRandomizer::StartEpoch: epoch 4: frames [21732..27165] (first sequence at sample 21732), data subset 0 of 1

07/14/2016 06:31:25: Starting minibatch loop.
07/14/2016 06:31:27: Finished Epoch[ 5 of 5]: [Training] ce = 1.33148531 * 1247; err = 0.44667201 * 1247; totalSamplesSeen = 6235; learningRatePerSample = 0.00050000002; epochTime=2.88706s
07/14/2016 06:31:27: SGD: Saving checkpoint model 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn'
07/14/2016 06:31:27: CNTKCommandTrainEnd: Train

07/14/2016 06:31:27: Action "train" complete.

07/14/2016 06:31:27: __COMPLETED__
=== Deleting last epoch data
==== Re-running from checkpoint
=== Running /cygdrive/c/jenkins/workspace/CNTK-Test-Windows-W1/x64/debug/cntk.exe configFile=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config/seqcla.cntk currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu DeviceId=0 timestamping=true makeMode=true
-------------------------------------------------------------------
Build info: 

		Built time: Jul 14 2016 05:11:35
		Last modified date: Thu Jul 14 03:20:47 2016
		Build type: Debug
		Build target: GPU
		With 1bit-SGD: no
		Math lib: mkl
		CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.5
		CUB_PATH: C:\src\cub-1.4.1
		CUDNN_PATH: c:\NVIDIA\cudnn-4.0\cuda
		Build Branch: HEAD
		Build SHA1: 72bee394bf461e8f6f0feb593a8416c05f481957
		Built by svcphil on liana-08-w
		Build Path: c:\jenkins\workspace\CNTK-Build-Windows\Source\CNTK\
-------------------------------------------------------------------
Changed current directory to C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
07/14/2016 06:31:29: -------------------------------------------------------------------
07/14/2016 06:31:29: Build info: 

07/14/2016 06:31:29: 		Built time: Jul 14 2016 05:11:35
07/14/2016 06:31:29: 		Last modified date: Thu Jul 14 03:20:47 2016
07/14/2016 06:31:29: 		Build type: Debug
07/14/2016 06:31:29: 		Build target: GPU
07/14/2016 06:31:29: 		With 1bit-SGD: no
07/14/2016 06:31:29: 		Math lib: mkl
07/14/2016 06:31:29: 		CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.5
07/14/2016 06:31:29: 		CUB_PATH: C:\src\cub-1.4.1
07/14/2016 06:31:29: 		CUDNN_PATH: c:\NVIDIA\cudnn-4.0\cuda
07/14/2016 06:31:29: 		Build Branch: HEAD
07/14/2016 06:31:29: 		Build SHA1: 72bee394bf461e8f6f0feb593a8416c05f481957
07/14/2016 06:31:29: 		Built by svcphil on liana-08-w
07/14/2016 06:31:29: 		Build Path: c:\jenkins\workspace\CNTK-Build-Windows\Source\CNTK\
07/14/2016 06:31:29: -------------------------------------------------------------------
07/14/2016 06:31:29: -------------------------------------------------------------------
07/14/2016 06:31:29: GPU info:

07/14/2016 06:31:29: 		Device[0]: cores = 2496; computeCapability = 5.2; type = "Quadro M4000"; memory = 8192 MB
07/14/2016 06:31:29: -------------------------------------------------------------------

07/14/2016 06:31:29: Running on cntk-muc01 at 2016/07/14 06:31:29
07/14/2016 06:31:29: Command line: 
C:\jenkins\workspace\CNTK-Test-Windows-W1\x64\debug\cntk.exe  configFile=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config/seqcla.cntk  currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data  RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu  DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data  ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config  OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu  DeviceId=0  timestamping=true  makeMode=true



07/14/2016 06:31:29: >>>>>>>>>>>>>>>>>>>> RAW CONFIG (VARIABLES NOT RESOLVED) >>>>>>>>>>>>>>>>>>>>
07/14/2016 06:31:29: RootDir = ".."
ConfigDir = "$RootDir$/Config"
DataDir   = "$RootDir$/Data"
OutputDir = "$RootDir$/Output"
ModelDir  = "$OutputDir$/Models"
command=Train 
deviceId = $DeviceId$
modelPath="$ModelDir$/seqcla.dnn"
Train=[
    action="train"
    run=BrainScriptNetworkBuilder
    BrainScriptNetworkBuilder=[
        Layers = [
            EmbeddingLayer(input, vocabSize, embeddingDim, embeddingPath) = [
                embedding = Transpose(LearnableParameter(vocabSize, embeddingDim, learningRateMultiplier = 0.0, init = 'fromFile', initFromFilePath = embeddingPath))          
                lookup = GatherPacked(features, embedding)
            ].lookup
            DenseLayer(input, inputSize, outputSize, activation) = [
               z = BFF(input, outputSize, inputSize).z
               act = activation(z)
            ].act
            LSTMLayer (input, inputSize, outputSize, cellSize, selector) = [ 
               lstm = BS.RNNs.RecurrentLSTMP (outputSize, cellDim=cellSize, input, inputDim=inputSize).h
               result = selector(lstm)
            ].result
        ]        
        // LSTM params
        lstmDim = 25
        cellDim = 25
        // model
        numLabels = 5        
        vocab = 2000
        embedDim = 50        
        // set up features and labels
        t = DynamicAxis()
features = Input(1, dynamicAxis=t)   
labels   = Input(numLabels)          
        // load the pre-learned word embedding matrix
        l1 = Layers.EmbeddingLayer(features, vocab, embedDim, 'embeddingmatrix.txt')
        l2 = Layers.LSTMLayer(l1, embedDim, lstmDim, cellDim, BS.Sequences.Last)
        l3 = Layers.DenseLayer(l2, lstmDim, numLabels, Pass)
        out = Pass(l3, tag='output')   
        // Make sure the trainer understands that the time dimension of l3 is actually the same as that of labels.
        l3p = ReconcileDynamicAxis(l3, labels)
        // training criteria
        ce  = CrossEntropyWithSoftmax(labels, l3p, tag='criterion')   // this is the training objective
        err = ErrorPrediction        (labels, l3p, tag='evaluation')  // this also gets tracked
    ]
    SGD = [	
        epochSize = 0
        minibatchSize = 200
        maxEpochs = 5
        momentumPerMB = 0.9
        learningRatesPerMB = 0.1
        keepCheckPointFiles = true
    ]
    reader = [
        readerType = "CNTKTextFormatReader"
        file = "$DataDir$/Train.txt"            
        input = [            
            features=[
                alias = "x"                
                dim = 1               
                format = "dense"
            ]
            labels=[
                alias = "y"                
                dim = 5           
                format = "dense"
            ]
        ]
   ]    
outputPath = "$OutputDir$/output.txt"        
]
Write=[
    action="test"
    run=BrainScriptNetworkBuilder
    format = [
      sequencePrologue=%d\t|w.shape %x\n%d\t|w\s
      sampleSeparator=\n%d\t|w\s
      elementSeparator=\s
    ]
    modelFile = "$ModelDir$/seqcla.dnn"    
    reader = [
            readerType = "CNTKTextFormatReader"
            file = "$DataDir$/Train.txt"            
            input = [            
                features=[
                    alias = "x"                
                    dim = 1               
                    format = "dense"
                ]
                labels=[
                    alias = "y"                
                    dim = 5           
                    format = "dense"
                ]
            ]
   ]    
outputPath = "$OutputDir$/output.txt"        
]
currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config
OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DeviceId=0
timestamping=true
makeMode=true

07/14/2016 06:31:29: <<<<<<<<<<<<<<<<<<<< RAW CONFIG (VARIABLES NOT RESOLVED)  <<<<<<<<<<<<<<<<<<<<

07/14/2016 06:31:29: >>>>>>>>>>>>>>>>>>>> RAW CONFIG WITH ALL VARIABLES RESOLVED >>>>>>>>>>>>>>>>>>>>
07/14/2016 06:31:29: RootDir = ".."
ConfigDir = "../Config"
DataDir   = "../Data"
OutputDir = "../Output"
ModelDir  = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models"
command=Train 
deviceId = 0
modelPath="C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn"
Train=[
    action="train"
    run=BrainScriptNetworkBuilder
    BrainScriptNetworkBuilder=[
        Layers = [
            EmbeddingLayer(input, vocabSize, embeddingDim, embeddingPath) = [
                embedding = Transpose(LearnableParameter(vocabSize, embeddingDim, learningRateMultiplier = 0.0, init = 'fromFile', initFromFilePath = embeddingPath))          
                lookup = GatherPacked(features, embedding)
            ].lookup
            DenseLayer(input, inputSize, outputSize, activation) = [
               z = BFF(input, outputSize, inputSize).z
               act = activation(z)
            ].act
            LSTMLayer (input, inputSize, outputSize, cellSize, selector) = [ 
               lstm = BS.RNNs.RecurrentLSTMP (outputSize, cellDim=cellSize, input, inputDim=inputSize).h
               result = selector(lstm)
            ].result
        ]        
        // LSTM params
        lstmDim = 25
        cellDim = 25
        // model
        numLabels = 5        
        vocab = 2000
        embedDim = 50        
        // set up features and labels
        t = DynamicAxis()
features = Input(1, dynamicAxis=t)   
labels   = Input(numLabels)          
        // load the pre-learned word embedding matrix
        l1 = Layers.EmbeddingLayer(features, vocab, embedDim, 'embeddingmatrix.txt')
        l2 = Layers.LSTMLayer(l1, embedDim, lstmDim, cellDim, BS.Sequences.Last)
        l3 = Layers.DenseLayer(l2, lstmDim, numLabels, Pass)
        out = Pass(l3, tag='output')   
        // Make sure the trainer understands that the time dimension of l3 is actually the same as that of labels.
        l3p = ReconcileDynamicAxis(l3, labels)
        // training criteria
        ce  = CrossEntropyWithSoftmax(labels, l3p, tag='criterion')   // this is the training objective
        err = ErrorPrediction        (labels, l3p, tag='evaluation')  // this also gets tracked
    ]
    SGD = [	
        epochSize = 0
        minibatchSize = 200
        maxEpochs = 5
        momentumPerMB = 0.9
        learningRatesPerMB = 0.1
        keepCheckPointFiles = true
    ]
    reader = [
        readerType = "CNTKTextFormatReader"
        file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
        input = [            
            features=[
                alias = "x"                
                dim = 1               
                format = "dense"
            ]
            labels=[
                alias = "y"                
                dim = 5           
                format = "dense"
            ]
        ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]
Write=[
    action="test"
    run=BrainScriptNetworkBuilder
    format = [
      sequencePrologue=%d\t|w.shape %x\n%d\t|w\s
      sampleSeparator=\n%d\t|w\s
      elementSeparator=\s
    ]
    modelFile = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn"    
    reader = [
            readerType = "CNTKTextFormatReader"
            file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
            input = [            
                features=[
                    alias = "x"                
                    dim = 1               
                    format = "dense"
                ]
                labels=[
                    alias = "y"                
                    dim = 5           
                    format = "dense"
                ]
            ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]
currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config
OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
DeviceId=0
timestamping=true
makeMode=true

07/14/2016 06:31:29: <<<<<<<<<<<<<<<<<<<< RAW CONFIG WITH ALL VARIABLES RESOLVED <<<<<<<<<<<<<<<<<<<<

07/14/2016 06:31:29: >>>>>>>>>>>>>>>>>>>> PROCESSED CONFIG WITH ALL VARIABLES RESOLVED >>>>>>>>>>>>>>>>>>>>
configparameters: seqcla.cntk:command=Train
configparameters: seqcla.cntk:ConfigDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Config
configparameters: seqcla.cntk:currentDirectory=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
configparameters: seqcla.cntk:DataDir=C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data
configparameters: seqcla.cntk:deviceId=0
configparameters: seqcla.cntk:makeMode=true
configparameters: seqcla.cntk:ModelDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models
configparameters: seqcla.cntk:modelPath=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn
configparameters: seqcla.cntk:OutputDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
configparameters: seqcla.cntk:RootDir=..
configparameters: seqcla.cntk:RunDir=C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu
configparameters: seqcla.cntk:timestamping=true
configparameters: seqcla.cntk:Train=[
    action="train"
    run=BrainScriptNetworkBuilder
    BrainScriptNetworkBuilder=[
        Layers = [
            EmbeddingLayer(input, vocabSize, embeddingDim, embeddingPath) = [
                embedding = Transpose(LearnableParameter(vocabSize, embeddingDim, learningRateMultiplier = 0.0, init = 'fromFile', initFromFilePath = embeddingPath))          
                lookup = GatherPacked(features, embedding)
            ].lookup
            DenseLayer(input, inputSize, outputSize, activation) = [
               z = BFF(input, outputSize, inputSize).z
               act = activation(z)
            ].act
            LSTMLayer (input, inputSize, outputSize, cellSize, selector) = [ 
               lstm = BS.RNNs.RecurrentLSTMP (outputSize, cellDim=cellSize, input, inputDim=inputSize).h
               result = selector(lstm)
            ].result
        ]        
        // LSTM params
        lstmDim = 25
        cellDim = 25
        // model
        numLabels = 5        
        vocab = 2000
        embedDim = 50        
        // set up features and labels
        t = DynamicAxis()
features = Input(1, dynamicAxis=t)   
labels   = Input(numLabels)          
        // load the pre-learned word embedding matrix
        l1 = Layers.EmbeddingLayer(features, vocab, embedDim, 'embeddingmatrix.txt')
        l2 = Layers.LSTMLayer(l1, embedDim, lstmDim, cellDim, BS.Sequences.Last)
        l3 = Layers.DenseLayer(l2, lstmDim, numLabels, Pass)
        out = Pass(l3, tag='output')   
        // Make sure the trainer understands that the time dimension of l3 is actually the same as that of labels.
        l3p = ReconcileDynamicAxis(l3, labels)
        // training criteria
        ce  = CrossEntropyWithSoftmax(labels, l3p, tag='criterion')   // this is the training objective
        err = ErrorPrediction        (labels, l3p, tag='evaluation')  // this also gets tracked
    ]
    SGD = [	
        epochSize = 0
        minibatchSize = 200
        maxEpochs = 5
        momentumPerMB = 0.9
        learningRatesPerMB = 0.1
        keepCheckPointFiles = true
    ]
    reader = [
        readerType = "CNTKTextFormatReader"
        file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
        input = [            
            features=[
                alias = "x"                
                dim = 1               
                format = "dense"
            ]
            labels=[
                alias = "y"                
                dim = 5           
                format = "dense"
            ]
        ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]

configparameters: seqcla.cntk:Write=[
    action="test"
    run=BrainScriptNetworkBuilder
    format = [
      sequencePrologue=%d\t|w.shape %x\n%d\t|w\s
      sampleSeparator=\n%d\t|w\s
      elementSeparator=\s
    ]
    modelFile = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn"    
    reader = [
            readerType = "CNTKTextFormatReader"
            file = "C:\jenkins\workspace\CNTK-Test-Windows-W1\Tests\EndToEndTests\Text\SequenceClassification\Data/Train.txt"            
            input = [            
                features=[
                    alias = "x"                
                    dim = 1               
                    format = "dense"
                ]
                labels=[
                    alias = "y"                
                    dim = 5           
                    format = "dense"
                ]
            ]
   ]    
outputPath = "C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/output.txt"        
]

07/14/2016 06:31:29: <<<<<<<<<<<<<<<<<<<< PROCESSED CONFIG WITH ALL VARIABLES RESOLVED <<<<<<<<<<<<<<<<<<<<
07/14/2016 06:31:29: Commands: Train
07/14/2016 06:31:29: Precision = "float"
07/14/2016 06:31:29: CNTKModelPath: C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn
07/14/2016 06:31:29: CNTKCommandTrainInfo: Train : 5
07/14/2016 06:31:29: CNTKCommandTrainInfo: CNTKNoMoreCommands_Total : 5

07/14/2016 06:31:29: ##############################################################################
07/14/2016 06:31:29: #                                                                            #
07/14/2016 06:31:29: # Action "train"                                                             #
07/14/2016 06:31:29: #                                                                            #
07/14/2016 06:31:29: ##############################################################################

07/14/2016 06:31:29: CNTKCommandTrainBegin: Train

07/14/2016 06:31:30: Starting from checkpoint. Loading network from 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn.4'.

Post-processing network...

4 roots:
	ce = CrossEntropyWithSoftmax()
	err = ErrorPrediction()
	out = Pass()
	t = DynamicAxis()

Loop[0] --> Loop_l2.lstm.lstmState._privateInnards.ht -> 25 nodes

	l2.lstm.prevState.h	l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1]	l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0]
	l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1]	l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0]	l2.lstm.prevState.c
	l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1]	l2.lstm.lstmState._privateInnards.ft._	l2.lstm.lstmState._privateInnards.ft
	l2.lstm.lstmState._privateInnards.bft	l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1]	l2.lstm.lstmState._privateInnards.it._.PlusArgs[0]
	l2.lstm.lstmState._privateInnards.it._.PlusArgs[1]	l2.lstm.lstmState._privateInnards.it._	l2.lstm.lstmState._privateInnards.it
	l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1]	l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z	l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1]
	l2.lstm.lstmState._privateInnards.bit	l2.lstm.lstmState._privateInnards.ct	l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1]
	l2.lstm.lstmState._privateInnards.ot._	l2.lstm.lstmState._privateInnards.ot	l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1]
	l2.lstm.lstmState._privateInnards.ht

Validating network. 71 nodes to process in pass 1.

Validating --> labels = InputValue() :  -> [5 x *]
Validating --> l3.z.W = LearnableParameter() :  -> [5 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> features = InputValue() :  -> [1 x t1]
Validating --> l1.embedding.x = LearnableParameter() :  -> [2000 x 50]
Validating --> l1.embedding = TransposeDimensions (l1.embedding.x) : [2000 x 50] -> [50 x 2000]
Validating --> l1.lookup = GatherPacked (features, l1.embedding) : [1 x t1], [50 x 2000] -> [50 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1]) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1]) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1]) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0] = LearnableParameter() :  -> [25]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 50]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0], l1.lookup) : [25 x 50], [50 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1]) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0] = LearnableParameter() :  -> [25 x 25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1]) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1]) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [25] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.ft._ = Plus (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0], l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1]) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft = Sigmoid (l2.lstm.lstmState._privateInnards.ft._) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bft = ElementTimes (l2.lstm.lstmState._privateInnards.ft, l2.lstm.prevState.c) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0] = Plus (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0], l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1]) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [25] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.it._ = Plus (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0], l2.lstm.lstmState._privateInnards.it._.PlusArgs[1]) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it = Sigmoid (l2.lstm.lstmState._privateInnards.it._) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25] -> [25]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z = Plus (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0], l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1]) : [25 x t1], [25] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1] = Tanh (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bit = ElementTimes (l2.lstm.lstmState._privateInnards.it, l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1]) : [25 x t1], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ct = Plus (l2.lstm.lstmState._privateInnards.bft, l2.lstm.lstmState._privateInnards.bit) : [25 x t1], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.lstmState._privateInnards.ct) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot._ = Plus (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0], l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1]) : [25 x t1], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot = Sigmoid (l2.lstm.lstmState._privateInnards.ot._) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1] = Tanh (l2.lstm.lstmState._privateInnards.ct) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ht = ElementTimes (l2.lstm.lstmState._privateInnards.ot, l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1]) : [25 x t1], [25 x t1] -> [25 x t1]
Validating --> l2.result.beginFlags.input.z.ElementTimesArgs[0] = Slice (l2.lstm.lstmState._privateInnards.ht) : [25 x t1] -> [1 x t1]
Validating --> BS.Constants.Zero = LearnableParameter() :  -> [1]
Validating --> l2.result.beginFlags.input.z = ElementTimes (l2.result.beginFlags.input.z.ElementTimesArgs[0], BS.Constants.Zero) : [1 x t1], [1] -> [1 x t1]
Validating --> l2.result.beginFlags.input = SumColumnElements (l2.result.beginFlags.input.z) : [1 x t1] -> [1 x t1]
Validating --> l2.result.beginFlags = FutureValue (l2.result.beginFlags.input) : [1 x t1] -> [1 x t1]
Validating --> l2.result.out.indexSequence.indexSequence = Where (l2.result.beginFlags) : [1 x t1] -> [1 x WhereNodeAxis]
Validating --> l2.result.out.indexSequence = PackedIndex (l2.lstm.lstmState._privateInnards.ht, l2.result.out.indexSequence.indexSequence) : [25 x t1], [1 x WhereNodeAxis] -> [1 x WhereNodeAxis]
Validating --> l2.result.out = GatherPacked (l2.result.out.indexSequence, l2.lstm.lstmState._privateInnards.ht) : [1 x WhereNodeAxis], [25 x t1] -> [25 x WhereNodeAxis]
Validating --> l3.z.z.PlusArgs[0] = Times (l3.z.W, l2.result.out) : [5 x 25], [25 x WhereNodeAxis] -> [5 x WhereNodeAxis]
Validating --> l3.z.B = LearnableParameter() :  -> [5 x 1]
Validating --> l3.z.z = Plus (l3.z.z.PlusArgs[0], l3.z.B) : [5 x WhereNodeAxis], [5 x 1] -> [5 x 1 x WhereNodeAxis]
Validating --> l3.act = Pass (l3.z.z) : [5 x 1 x WhereNodeAxis] -> [5 x 1 x WhereNodeAxis]
Validating --> l3p = ReconcileDynamicAxis (l3.act, labels) : [5 x 1 x WhereNodeAxis], [5 x *] -> [5 x 1 x *]
Validating --> ce = CrossEntropyWithSoftmax (labels, l3p) : [5 x *], [5 x 1 x *] -> [1]
Validating --> err = ErrorPrediction (labels, l3p) : [5 x *], [5 x 1 x *] -> [1]
Validating --> out = Pass (l3.act) : [5 x 1 x WhereNodeAxis] -> [5 x 1 x WhereNodeAxis]
Validating --> t = DynamicAxis() :  -> [1 x 1 x t1]

Validating network. 49 nodes to process in pass 2.

Validating --> l2.lstm.prevState.h = PastValue (l2.lstm.lstmState._privateInnards.ht) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.prevState.c = PastValue (l2.lstm.lstmState._privateInnards.ct) : [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] = ElementTimes (l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0], l2.lstm.prevState.c) : [25], [25 x t1] -> [25 x t1]
Validating --> l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] = Times (l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0], l2.lstm.prevState.h) : [25 x 25], [25 x t1] -> [25 x t1]

Validating network. 8 nodes to process in pass 3.


Validating network, final pass.



69 out of 71 nodes do not share the minibatch layout with the input data.

Post-processing network complete.

07/14/2016 06:31:31: Loaded model with 71 nodes on GPU 0.

07/14/2016 06:31:31: Training criterion node(s):
07/14/2016 06:31:31: 	ce = CrossEntropyWithSoftmax

07/14/2016 06:31:31: Evaluation criterion node(s):

07/14/2016 06:31:31: 	err = ErrorPrediction


Allocating matrices for forward and/or backward propagation.

Memory Sharing Structure:

0000000000000000: {[BS.Constants.Zero Gradient[1]] [err Gradient[1]] [features Gradient[1 x t1]] [l1.embedding Gradient[50 x 2000]] [l1.embedding.x Gradient[2000 x 50]] [l1.lookup Gradient[50 x t1]] [labels Gradient[5 x *]] [out Gradient[5 x 1 x WhereNodeAxis]] [t Gradient[1 x 1 x t1]] [t Value[1 x 1 x t1]] }
0000005C19C36840: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Value[25]] }
0000005C19C36910: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000005C19C36AB0: {[l1.embedding.x Value[2000 x 50]] }
0000005C19C36B80: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0] Value[25]] }
0000005C19C36F90: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000005C19C37060: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000005C19C37130: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0] Value[25]] }
0000005C19C37540: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Value[25]] }
0000005C19C37950: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000005C19C37A20: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000005C19C37C90: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 25]] }
0000005C19C37D60: {[features Value[1 x t1]] }
0000005C19C37E30: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0] Value[25]] }
0000005C19C37FD0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Value[25]] }
0000005C19E0D160: {[ce Gradient[1]] }
0000005C19E0D230: {[l2.lstm.lstmState._privateInnards.ht Value[25 x t1]] }
0000005C19E0D300: {[l2.lstm.lstmState._privateInnards.ot Value[25 x t1]] }
0000005C19E0D3D0: {[l2.lstm.lstmState._privateInnards.it Gradient[25 x t1]] }
0000005C19E0D4A0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1] Value[25 x t1]] }
0000005C19E0D570: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0] Gradient[25]] [l2.result.out Gradient[25 x WhereNodeAxis]] [l3.z.z Gradient[5 x 1 x WhereNodeAxis]] [l3p Value[5 x 1 x *]] }
0000005C19E0D710: {[l2.lstm.lstmState._privateInnards.ct Value[25 x t1]] }
0000005C19E0D7E0: {[l2.lstm.lstmState._privateInnards.ot Gradient[25 x t1]] [l2.result.beginFlags.input.z.ElementTimesArgs[0] Value[1 x t1]] }
0000005C19E0D980: {[l2.lstm.lstmState._privateInnards.bft Gradient[25 x t1]] [l3p Gradient[5 x 1 x *]] }
0000005C19E0DB20: {[l2.lstm.lstmState._privateInnards.ht Gradient[25 x t1]] [l3.act Value[5 x 1 x WhereNodeAxis]] [l3.z.z.PlusArgs[0] Gradient[5 x WhereNodeAxis]] }
0000005C19E0DBF0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z Gradient[25 x t1]] }
0000005C19E0DCC0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0] Gradient[25 x t1]] [l2.result.beginFlags.input Gradient[1 x t1]] [l2.result.out Value[25 x WhereNodeAxis]] [l2.result.out.indexSequence.indexSequence Gradient[1 x WhereNodeAxis]] }
0000005C19E0DD90: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1] Gradient[25 x t1]] [l2.result.beginFlags Gradient[1 x t1]] [l2.result.out.indexSequence Gradient[1 x WhereNodeAxis]] [l3.z.z.PlusArgs[0] Value[5 x WhereNodeAxis]] }
0000005C19E0DF30: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] Gradient[25 x t1]] }
0000005C19E0E000: {[l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1] Gradient[25 x t1]] [l2.result.beginFlags.input Value[1 x t1]] [l2.result.beginFlags.input.z.ElementTimesArgs[0] Gradient[1 x t1]] }
0000005C19E0E0D0: {[l3.act Gradient[5 x 1 x WhereNodeAxis]] [l3.z.B Gradient[5 x 1]] }
0000005C19E0E1A0: {[l2.lstm.lstmState._privateInnards.bit Value[25 x t1]] }
0000005C19E0E270: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z Value[25 x t1]] }
0000005C19E0E340: {[l2.lstm.lstmState._privateInnards.ot._ Value[25 x t1]] }
0000005C19E0E410: {[l2.lstm.lstmState._privateInnards.ht.ElementTimesArgs[1] Value[25 x t1]] }
0000005C19E0E4E0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1] Gradient[25 x t1]] }
0000005C19E0E750: {[l2.lstm.lstmState._privateInnards.bit Gradient[25 x t1]] }
0000005C19E0E820: {[l3.z.W Gradient[5 x 25]] [l3.z.z Value[5 x 1 x WhereNodeAxis]] }
0000005C19E0E8F0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0] Gradient[25 x t1]] }
0000005C19E0E9C0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000005C19E0EA90: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] [l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] [l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] [l2.lstm.prevState.h Gradient[25 x t1]] }
0000005C19E0EB60: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1] Value[25 x t1]] }
0000005C19E0EC30: {[l2.lstm.lstmState._privateInnards.it._ Gradient[25 x t1]] }
0000005C19E0ED00: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[1] Value[25 x t1]] }
0000005C19E0EDD0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0] Gradient[25 x t1]] }
0000005C19E0EEA0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] Gradient[25 x t1]] }
0000005C19E0EF70: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1].ElementTimesArgs[0] Gradient[25]] }
0000005C19E0F040: {[l2.lstm.lstmState._privateInnards.ct Gradient[25 x t1]] [l2.result.beginFlags.input.z Value[1 x t1]] }
0000005C19E11180: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000005C19E11250: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000005C19E113F0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1].ElementTimesArgs[0] Gradient[25]] }
0000005C19E114C0: {[l2.lstm.lstmState._privateInnards.ft Gradient[25 x t1]] }
0000005C19E11590: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] }
0000005C19E11660: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 25]] }
0000005C19E11730: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] }
0000005C19E11800: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] Gradient[25 x t1]] }
0000005C19E11E80: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0] Gradient[25 x t1]] }
0000005C19E12020: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0] Gradient[25 x t1]] }
0000005C19E12290: {[l2.lstm.prevState.c Gradient[25 x t1]] }
0000005C19E12500: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0] Gradient[25 x t1]] }
0000005C19E12D20: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0] Gradient[25 x t1]] }
0000005C19E12F90: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] Gradient[25 x t1]] }
0000005C19E13060: {[l2.lstm.lstmState._privateInnards.ft._ Gradient[25 x t1]] }
0000005C7CDC0070: {[BS.Constants.Zero Value[1]] }
0000005C7D6FEF80: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[1] Value[25 x t1]] }
0000005C7D6FF050: {[l3.z.W Value[5 x 25]] }
0000005C7D6FF120: {[l1.lookup Value[50 x t1]] }
0000005C7D6FF1F0: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0] Value[25 x t1]] [l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000005C7D6FF2C0: {[l2.result.out.indexSequence Value[1 x WhereNodeAxis]] }
0000005C7D6FF390: {[labels Value[5 x *]] }
0000005C7D6FF460: {[l2.lstm.lstmState._privateInnards.ft._ Value[25 x t1]] }
0000005C7D6FF530: {[err Value[1]] }
0000005C7D6FF600: {[l2.lstm.lstmState._privateInnards.bft Value[25 x t1]] }
0000005C7D6FF6D0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0] Value[25 x t1]] }
0000005C7D6FF7A0: {[l2.lstm.lstmState._privateInnards.it._ Value[25 x t1]] }
0000005C7D6FF940: {[l2.lstm.lstmState._privateInnards.it Value[25 x t1]] }
0000005C7D6FFA10: {[l2.lstm.prevState.c Value[25 x t1]] }
0000005C7D6FFAE0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Value[25 x t1]] [l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Gradient[25]] }
0000005C7D6FFBB0: {[out Value[5 x 1 x WhereNodeAxis]] }
0000005C7D6FFC80: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0] Value[25 x t1]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000005C7D6FFD50: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[1] Value[25 x t1]] }
0000005C7D6FFE20: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[1] Value[25 x t1]] }
0000005C7D6FFEF0: {[l2.lstm.lstmState._privateInnards.it._.PlusArgs[1] Value[25 x t1]] }
0000005C7D6FFFC0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 50]] }
0000005C7D700090: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[0] Gradient[25]] [l2.lstm.prevState.h Value[25 x t1]] }
0000005C7D700160: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0] Value[25 x t1]] [l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000005C7D700230: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0] Value[25 x t1]] [l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[1].TimesArgs[0] Gradient[25 x 50]] }
0000005C7D700300: {[l2.lstm.lstmState._privateInnards.bit.ElementTimesArgs[1].z.PlusArgs[0].PlusArgs[1] Value[25 x t1]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Gradient[25]] }
0000005C7D7003D0: {[l2.lstm.lstmState._privateInnards.ot._ Gradient[25 x t1]] [l2.result.beginFlags Value[1 x t1]] [l2.result.beginFlags.input.z Gradient[1 x t1]] }
0000005C7D7004A0: {[l2.result.out.indexSequence.indexSequence Value[1 x WhereNodeAxis]] }
0000005C7D700570: {[l3.z.B Value[5 x 1]] }
0000005C7D700640: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0].PlusArgs[0].PlusArgs[0] Gradient[25]] [l2.lstm.lstmState._privateInnards.it._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Value[25 x t1]] }
0000005C7D700710: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0] Value[25 x t1]] }
0000005C7D7007E0: {[l2.lstm.lstmState._privateInnards.ft Value[25 x t1]] }
0000005C7D7008B0: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[0].PlusArgs[1] Value[25 x t1]] }
0000005C7D700980: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1] Value[25 x t1]] }
0000005C7D700B20: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[1].ElementTimesArgs[0] Value[25]] }
0000005C7D700BF0: {[ce Value[1]] }
0000005C7D700CC0: {[l2.lstm.lstmState._privateInnards.ft._.PlusArgs[0] Value[25 x t1]] }
0000005C7D700D90: {[l1.embedding Value[50 x 2000]] }
0000005C7D700E60: {[l2.lstm.lstmState._privateInnards.ot._.PlusArgs[0].PlusArgs[1].TimesArgs[0] Value[25 x 25]] }

07/14/2016 06:31:31: No PreCompute nodes found, skipping PreCompute step.

07/14/2016 06:31:31: Starting Epoch 5: learning rate per sample = 0.000500  effective momentum = 0.900000  momentum as time constant = 1898.2 samples
BlockRandomizer::StartEpoch: epoch 4: frames [21732..27165] (first sequence at sample 21732), data subset 0 of 1

07/14/2016 06:31:31: Starting minibatch loop.
WARNING: The same matrix with dim [1, 44] has been transferred between different devices for 20 times.
07/14/2016 06:31:34: Finished Epoch[ 5 of 5]: [Training] ce = 1.33148531 * 1247; err = 0.44667201 * 1247; totalSamplesSeen = 6235; learningRatePerSample = 0.00050000002; epochTime=3.21796s
07/14/2016 06:31:34: SGD: Saving checkpoint model 'C:\Users\svcphil\AppData\Local\Temp\cntk-test-20160714055016.501646\Text_SequenceClassification@debug_gpu/Models/seqcla.dnn'
07/14/2016 06:31:34: CNTKCommandTrainEnd: Train

07/14/2016 06:31:34: Action "train" complete.

07/14/2016 06:31:34: __COMPLETED__