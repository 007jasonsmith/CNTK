load=ndlMacroDefine
run=ndlCreateNetwork

ndlMacroDefine=[
    # Macro definitions
    DelayNode(x)
    {
        D=Delay(x, delayInput=Dout, delayTime=1);
    }


    MeanVarNorm(x)=[
	xMean = Mean(x);
    	xStdDev = InvStdDev(x)
    	xNorm=PerDimMeanVarNormalization(x,xMean,xStdDev)
    ]
 
    #inline Rectified Linear Feed Forward
    RFF_R(x1, w1, b1)=RectifiedLinear(Plus(Times(w1,x1),b1))
    #Feed Forward
    FF(X1, W1, B1)
    [
        T=Times(W1,X1);
        P=Plus(T, B1);
    ]
    #Base feed Forward network, defines Bias and wieght parameters
    BFF(in, rows, cols)
    {
        B=Parameter(rows, init=fixedvalue, value=0)
        W=Parameter(rows, cols)
        FF = FF(in, w, b)
    }
    #RectifiedLinear Base Feed Forward
    RBFF(in,rowCount,colCount)
    {
        BFF = BFF(in, rowCount, colCount);
        RL = RectifiedLinear(BFF);
    }
    #Rectified Linear Feed Forward
    RFF(X2,W2,B2)=[
        FF = FF(X2, W2, B2);
        RL = RectifiedLinear(FF);
    ]
    #RectifiedLinear Feed Forward with Dropout
    RFFD(X3,W3,B3)
    {
        RFF=RFF(X3, W3, B3)
        DO=Dropout(RFF)
    }
    #Sigmoid Base Feed Forward
    SBFF(in,rowCount,colCount)
     {
        BFF = BFF(in, rowCount, colCount);
        S = Sigmoid(BFF);
    }
    #Sigmoid Feed Forward
    SFF(X2,W2,B2)=[
        FF = FF(X2, W2, B2);
        S = Sigmoid(FF);
    ]
    #Sigmoid Feed Forward with Dropout
    SFFD(X3,W3,B3)
    {
        SFF=SFF(X3, W3, B3)
        DO=Dropout(SFF)
    }
    #Sigmoid Feed Forward with Dropout
    SBFFD(input,rowCount,colCount)
    {
        SBFF=SBFF(input,rowCount,colCount)
        DO=Dropout(SBFF)
    }
    #SoftMax Feed Forward
    SMFF(x,y,z, labels)
    {
        FF = FF(x,y,z);
        SM = CrossEntropyWithSoftmax(labels, FF)
    }
    #SoftMax Base Feed Forward
    SMBFF(x,r,c, labels)
    {
        BFF = BFF(x,r,c);
        SM = CrossEntropyWithSoftmax(labels, BFF)
    }
    
    RFFD_R(x1, w1, b1)={Dropout(RectifiedLinear(Plus(Times(w1,x1),b1)))}

    LogPrior(labels)
    {
	Prior=Mean(labels)
	LogPrior=Log(Prior)
    }   

    #Sigmoid Base Feed Forward with multiple input
    SBFF_multi(in1, in2, rowCount, colCount1, colCount2)
     {
        BFF1 = BFF(in1, rowCount, colCount1);
        BFF2 = BFF(in2, rowCount, colCount2);
        B=Parameter(rowCount, init=fixedvalue, value=0.1)
        
        BFF_final = Plus(BFF1, BFF2)
        S = Sigmoid(BFF_final);
    }

     BFF_multi(in1, in2, rowCount, colCount1, colCount2)
     {
        BFF1 = BFF(in1, rowCount, colCount1);
        BFF2 = BFF(in2, rowCount, colCount2);
        B=Parameter(rowCount, init=fixedvalue, value=0.1)
        
        BFF_final = Plus(BFF1, BFF2)
    }

    LSTMComponent(inputDim, outputDim, input)
    {
        Wxo = Parameter(outputDim, inputDim);
        Wxi = Parameter(outputDim, inputDim);
        Wxf = Parameter(outputDim, inputDim);
        Wxc = Parameter(outputDim, inputDim);

        bo = Parameter(outputDim, init=fixedvalue, value=-1.0);
        bc = Parameter(outputDim, init=fixedvalue, value=0.0);
        bi = Parameter(outputDim, init=fixedvalue, value=-1.0);
        bf = Parameter(outputDim, init=fixedvalue, value=-1.0);

        Whi = Parameter(outputDim, outputDim);
        Wci = Parameter(outputDim);
        Whf = Parameter(outputDim, outputDim);
        Wcf = Parameter(outputDim);
        Who = Parameter(outputDim, outputDim);
        Wco = Parameter(outputDim);
        Whc = Parameter(outputDim, outputDim);

        delayHI = Delay(outputDim, outputTest, delayTime=1);
        delayHF = Delay(outputDim, outputTest, delayTime=1);
        delayHO = Delay(outputDim, outputTest, delayTime=1);
        delayHC = Delay(outputDim, outputTest, delayTime=1);
        delayCI = Delay(outputDim, ct, delayTime=1);
        delayCF = Delay(outputDim, ct, delayTime=1);
        delayCC = Delay(outputDim, ct, delayTime=1);

        WxiInput = Times(Wxi, input);
        WhidelayHI = Times(Whi, delayHI);
        WcidelayCI = DiagTimes(Wci, delayCI);

        it = Sigmoid (Plus ( Plus (Plus (WxiInput, bi), WhidelayHI), WcidelayCI));

        WxcInput = Times(Wxc, input);
        WhcdelayHC = Times(Whc, delayHC);
        bit = ElementTimes(it, Tanh( Plus(WxcInput, Plus(WhcdelayHC, bc))));
        
        Wxfinput = Times(Wxf, input);
        WhfdelayHF = Times(Whf, delayHF);
        WcfdelayCF = DiagTimes(Wcf, delayCF);

        ft = Sigmoid( Plus (Plus (Plus(Wxfinput, bf), WhfdelayHF), WcfdelayCF));

        bft = ElementTimes(ft, delayCC);

        ct = Plus(bft, bit);

        Wxoinput = Times(Wxo, input);
        WhodelayHO = Times(Who, delayHO);
        Wcoct = DiagTimes(Wco, ct);

        ot = Sigmoid( Plus( Plus( Plus(Wxoinput, bo), WhodelayHO), Wcoct));

        outputTest = ElementTimes(ot, Tanh(ct));
        
        
    }


]


ndlCreateNetwork=[

	#define basic i/o
	featDim=2000
	labelDim=183
	hiddenDim=200
    #bottleneckDim=500
	features=Input(featDim, tag=feature)
	labels=Input(labelDim, tag=label)

	# define network
	featNorm = MeanVarNorm(features)
    
    LSTMoutput = LSTMComponent(featDim, hiddenDim, featNorm);
    W1 = Parameter(labelDim, hiddenDim);

    LSTMoutputW1 = Times(W1, LSTMoutput);

    cr = CrossEntropyWithSoftmax(labels, LSTMoutputW1,tag=Criteria);
    Err = ErrorPrediction(labels,LSTMoutputW1,tag=Eval);
    
    logPrior = LogPrior(labels)	 

    ScaledLogLikelihood=Minus(LSTMoutputW1,logPrior,tag=Output)

   
	# define output (scaled loglikelihood)
	#ScaledLogLikelihood=Minus(CE_BFF,logPrior,tag=Output)
]
