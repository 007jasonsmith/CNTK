#pragma once

#include <hash_map>
#include "simplesenonehmm.h"
#include "latticearchive.h"
#include "minibatchiterator.h"
#include "Matrix.h"

namespace msra {
    namespace lattices {
        template<class ElemType>
        class GammaCalculation
        {
            bool cpumode;
        public:
            GammaCalculation() : cpumode(false)
            {
                initialmark = false;
                lmf = 14.0f; // Note that 9 was best for Fisher  --these should best be configurable
                wp = 0.0f;
                amf = 14.0f;
                boostmmifactor = 0.0f;
                seqsMBRmode = false;
            }
            ~GammaCalculation()
            {

            }

            void init(msra::asr::simplesenonehmm hset, int DeviceId)
            {
                m_deviceid = DeviceId;
                if (!initialmark)
                {
                    m_hset = hset;
                    m_maxframenum = 0;

                    // prep for parallel implementation (CUDA)
                    if (DeviceId == CPUDEVICE)
                        parallellattice.setmode(true);
                    else
                    {
                        
                        parallellattice.setmode(false);
                    }
                        
                    
                    if (parallellattice.enabled())                   // send hmm set to GPU if GPU computation enabled
                        parallellattice.entercomputation(m_hset, mbrclassdef);       // cache senone2classmap if mpemode 
                    initialmark = true;
                }
            }
            //void init(msra::asr::simplesenonehmm hset, int DeviceId);
            
            
            void calgammaformb(std::vector<shared_ptr<const msra::dbn::latticesource::latticepair>> &lattices, const Microsoft::MSR::CNTK::Matrix<ElemType>& loglikelihood,
                Microsoft::MSR::CNTK::Matrix<ElemType>&  labels, Microsoft::MSR::CNTK::Matrix<ElemType>& functionValues, std::vector<size_t> &uids, std::vector<size_t> &boundaries,
				size_t samplesInRecurrentStep, Microsoft::MSR::CNTK::Matrix<ElemType>& sentenceSeg, std::vector<size_t> &extrauttmap, bool doreferencealign)
            {
                //check total frame number to be added ?
                //int deviceid = loglikelihood.GetDeviceId();
				size_t boundaryframenum;
				std::vector<size_t> validframes;
				validframes.assign(samplesInRecurrentStep, 0);
                //convert from Microsoft::MSR::CNTK::Matrix to  msra::math::ssematrixbase
                size_t numrows = loglikelihood.GetNumRows();
                size_t numcols = loglikelihood.GetNumCols();                
				
				tempmatrix.TransferFromDeviceToDevice(tempmatrix.GetDeviceId(), m_deviceid);
                //copy loglikelihood to pred
                if (numcols > pred.cols())
                {
                    pred.resize(numrows, numcols);
                    dengammas.resize(numrows, numcols);
                }

                if (doreferencealign)
                    labels.SetValue((ElemType)(0.0f));
                
				size_t mbsize = numcols / samplesInRecurrentStep;                
				if (samplesInRecurrentStep > 1)
				{
					assert(extrauttmap.size() == lattices.size());
					assert(mbsize == sentenceSeg.GetNumCols());
				}
                
				size_t mapi = 0;
				size_t mapframenum = 0;
				//cal gamma for each utterance
				size_t ts = 0;
				//size_t ts_uid = 0;                
                for (size_t i = 0; i < lattices.size(); i++)
                {
					const size_t numframes = lattices[i]->getnumframes();

					msra::dbn::matrixstripe predstripe(pred, ts, numframes);           // logLLs for this utterance					
					msra::dbn::matrixstripe dengammasstripe(dengammas, ts, numframes); // denominator gammas

										
					if (samplesInRecurrentStep == 1)  //one channel 
					{
						tempmatrix = loglikelihood.ColumnSlice(ts, numframes);
						if (m_deviceid == CPUDEVICE)
						{
							ElemType *datap = tempmatrix.CopyToArray();
							memcpy(&predstripe(0, 0), (float *)datap, sizeof(float)*numrows*numframes);
							delete datap;
						}
						else
							parallellattice.setloglls((float *)(tempmatrix.BufferPointer()), numrows, numframes);						
					}
					else                   //multi channel
					{
						//get frame number for each utterance
						mapi = extrauttmap[i];
						
						for (size_t j = validframes[mapi]; j < mbsize; j++)
						{
							if (sentenceSeg(mapi, j) == (ElemType)SENTENCE_END)
							{
								mapframenum = j - validframes[mapi] + 1;
								break;
								//validframes.push_back(j + 1);								
							}
						}					

						
						assert(numframes == mapframenum);

						if (numframes > tempmatrix.GetNumCols())
							tempmatrix.Resize(numrows, numframes);

						for (size_t nframe = 0; nframe < numframes; nframe++)
						{
							Microsoft::MSR::CNTK::Matrix<ElemType> columndata = loglikelihood.ColumnSlice((nframe + validframes[mapi])*samplesInRecurrentStep + mapi, 1);
							tempmatrix.SetColumn(columndata, nframe);
						}

						if (doreferencealign || m_deviceid == CPUDEVICE)
						{
							ElemType *datap = tempmatrix.CopyToArray();
							memcpy(&predstripe(0, 0), (float *)datap, sizeof(float)*numrows*numframes);
							delete datap;
						}
						if (m_deviceid != CPUDEVICE)
						{							
							parallellattice.setloglls((float *)(tempmatrix.BufferPointer()), numrows, numframes);
						}

						/*size_t pnumrow = logllmatrix.GetNumRows();
						size_t pnumcol = logllmatrix.GetNumCols();
						logllmatrix.Print("data value 1", 0, min(10, pnumrow) - 1, 0, min(10, pnumcol) - 1);
						logllmatrix.Print("data value 2", 0, min(10, pnumrow) - 1, pnumcol - 11, pnumcol - 1);
						float fnorm = (float)(logllmatrix.FrobeniusNorm());
						fprintf(stderr, "fnorm %f\n", fnorm);*/
					}
                    
                    
                    array_ref<size_t> uidsstripe(&uids[ts], numframes);
                    
                    if (doreferencealign)
                    {
                        boundaryframenum = numframes;                        
                    }
                    else
                        boundaryframenum = 0;
                    array_ref<size_t> boundariesstripe(&boundaries[ts], boundaryframenum);                    
                    
                    //auto_timer dengammatimer;
					double denavlogp = lattices[i]->second.forwardbackward(parallellattice,
                        (const msra::math::ssematrixbase &) predstripe, (const msra::asr::simplesenonehmm &) m_hset,
                        (msra::math::ssematrixbase &) dengammasstripe, (msra::math::ssematrixbase &) gammasbuffer/*empty, not used*/,
                        lmf, wp, amf, boostmmifactor, seqsMBRmode, uidsstripe, boundariesstripe);

					if (samplesInRecurrentStep == 1)
					{
						tempmatrix = functionValues.ColumnSlice(ts, numframes);
					}

					//copy gamma to tempmatrix
					if (m_deviceid == CPUDEVICE)
					{
						ElemType * outp = new ElemType[numrows*numframes];
						memcpy((float *)outp, &dengammas(0, 0), sizeof(float)*numrows*numframes);						
						tempmatrix.SetValue(numrows, numframes, outp, 0, functionValues.GetDeviceId());
						delete outp;
					}
					else
						parallellattice.getgamma((float *)(tempmatrix.BufferPointer()), numrows, numframes);

					// set gamma for multi channel
					if (samplesInRecurrentStep > 1)
					{						
                        for (size_t nframe = 0; nframe < numframes; nframe++)
                        {
							Microsoft::MSR::CNTK::Matrix<ElemType> columndata = tempmatrix.ColumnSlice(nframe, 1);
                            functionValues.SetColumn(columndata, (nframe+validframes[mapi])*samplesInRecurrentStep + mapi);                                
                        }
                    }

					if (doreferencealign)
                    {
                        for (size_t nframe = 0; nframe < numframes; nframe++)
                        {
                            size_t uid = uidsstripe[nframe];
                            if (samplesInRecurrentStep > 1)
								labels(uid, (nframe + validframes[mapi])*samplesInRecurrentStep + mapi) = 1.0;
                            else
                                labels(uid, ts+nframe) = 1.0;
                        }
                    }
					if (samplesInRecurrentStep > 1)
						validframes[mapi] += numframes;
                    fprintf(stderr, "dengamma value %f\n", denavlogp);
                    /*if (samplesInRecurrentStep == 1)
                        ts += numframes;
                    else
                        ts = (i+1) * mbsize;*/
                    ts += numframes;
                }       

               // parallellattice.release(false);
            }
            
			float doCTC(const Microsoft::MSR::CNTK::Matrix<ElemType>& prob, Microsoft::MSR::CNTK::Matrix<ElemType>& functionValues, std::vector<size_t> &uids,
				size_t samplesInRecurrentStep, std::vector<size_t>& validframes)
				//UMATRIX & Pugv, UMATRIX & uids, const UIDSVECTOR & phoneboundary)
			{				
				std::vector<size_t> validframes;
				validframes.assign(samplesInRecurrentStep, 0);
				//convert from Microsoft::MSR::CNTK::Matrix to  msra::math::ssematrixbase
				size_t numrows = loglikelihood.GetNumRows();
				size_t numcols = loglikelihood.GetNumCols();

				m_deviceid = prob.GetDeviceId();
				tempmatrix.TransferFromDeviceToDevice(tempmatrix.GetDeviceId(), m_deviceid);
				Microsoft::MSR::CNTK::Matrix<ElemType> alpha(m_deviceid);
				Microsoft::MSR::CNTK::Matrix<ElemType> beta(m_deviceid);

				ElemType finalscore = 0;
				
				std::vector<size_t> phoneseq;
				size_t blankid = numrows - 1;

				//copy loglikelihood to pred
				if (numcols > pred.cols())
				{
					pred.resize(numrows, numcols);
					dengammas.resize(numrows, numcols);
				}

				if (doreferencealign)
					labels.SetValue((ElemType)(0.0f));

				size_t mbsize = numcols / samplesInRecurrentStep;
				if (samplesInRecurrentStep > 1)
				{
					assert(extrauttmap.size() == lattices.size());
					assert(mbsize == sentenceSeg.GetNumCols());
				}

				size_t mapi = 0;
				size_t mapframenum = 0;
				//cal gamma for each utterance
				size_t ts = 0;
				//size_t ts_uid = 0;                
				for (size_t i = 0; i < lattices.size(); i++)
				{
					const size_t numframes = lattices[i]->getnumframes();

					msra::dbn::matrixstripe predstripe(pred, ts, numframes);           // logLLs for this utterance					
					msra::dbn::matrixstripe dengammasstripe(dengammas, ts, numframes); // denominator gammas


					if (samplesInRecurrentStep == 1)  //one channel 
					{
						tempmatrix = loglikelihood.ColumnSlice(ts, numframes);
						if (m_deviceid == CPUDEVICE)
						{
							ElemType *datap = tempmatrix.CopyToArray();
							memcpy(&predstripe(0, 0), (float *)datap, sizeof(float)*numrows*numframes);
							delete datap;
						}
						else
							parallellattice.setloglls((float *)(tempmatrix.BufferPointer()), numrows, numframes);
					}
					else                   //multi channel
					{
						//get frame number for each utterance
						mapi = extrauttmap[i];

						for (size_t j = validframes[mapi]; j < mbsize; j++)
						{
							if (sentenceSeg(mapi, j) == (ElemType)SENTENCE_END)
							{
								mapframenum = j - validframes[mapi] + 1;
								break;
								//validframes.push_back(j + 1);								
							}
						}


						assert(numframes == mapframenum);

						if (numframes > tempmatrix.GetNumCols())
							tempmatrix.Resize(numrows, numframes);

						for (size_t nframe = 0; nframe < numframes; nframe++)
						{
							Microsoft::MSR::CNTK::Matrix<ElemType> columndata = loglikelihood.ColumnSlice((nframe + validframes[mapi])*samplesInRecurrentStep + mapi, 1);
							tempmatrix.SetColumn(columndata, nframe);
						}

						if (doreferencealign || m_deviceid == CPUDEVICE)
						{
							ElemType *datap = tempmatrix.CopyToArray();
							memcpy(&predstripe(0, 0), (float *)datap, sizeof(float)*numrows*numframes);
							delete datap;
						}
						if (m_deviceid != CPUDEVICE)
						{
							parallellattice.setloglls((float *)(tempmatrix.BufferPointer()), numrows, numframes);
						}

						/*size_t pnumrow = logllmatrix.GetNumRows();
						size_t pnumcol = logllmatrix.GetNumCols();
						logllmatrix.Print("data value 1", 0, min(10, pnumrow) - 1, 0, min(10, pnumcol) - 1);
						logllmatrix.Print("data value 2", 0, min(10, pnumrow) - 1, pnumcol - 11, pnumcol - 1);
						float fnorm = (float)(logllmatrix.FrobeniusNorm());
						fprintf(stderr, "fnorm %f\n", fnorm);*/
					}


					array_ref<size_t> uidsstripe(&uids[ts], numframes);

					if (doreferencealign)
					{
						boundaryframenum = numframes;
					}
					else
						boundaryframenum = 0;
					array_ref<size_t> boundariesstripe(&boundaries[ts], boundaryframenum);

					//auto_timer dengammatimer;
					double denavlogp = lattices[i]->second.forwardbackward(parallellattice,
						(const msra::math::ssematrixbase &) predstripe, (const msra::asr::simplesenonehmm &) m_hset,
						(msra::math::ssematrixbase &) dengammasstripe, (msra::math::ssematrixbase &) gammasbuffer/*empty, not used*/,
						lmf, wp, amf, boostmmifactor, seqsMBRmode, uidsstripe, boundariesstripe);

					if (samplesInRecurrentStep == 1)
					{
						tempmatrix = functionValues.ColumnSlice(ts, numframes);
					}

					//copy gamma to tempmatrix
					if (m_deviceid == CPUDEVICE)
					{
						ElemType * outp = new ElemType[numrows*numframes];
						memcpy((float *)outp, &dengammas(0, 0), sizeof(float)*numrows*numframes);
						tempmatrix.SetValue(numrows, numframes, outp, 0, functionValues.GetDeviceId());
						delete outp;
					}
					else
						parallellattice.getgamma((float *)(tempmatrix.BufferPointer()), numrows, numframes);

					// set gamma for multi channel
					if (samplesInRecurrentStep > 1)
					{
						for (size_t nframe = 0; nframe < numframes; nframe++)
						{
							Microsoft::MSR::CNTK::Matrix<ElemType> columndata = tempmatrix.ColumnSlice(nframe, 1);
							functionValues.SetColumn(columndata, (nframe + validframes[mapi])*samplesInRecurrentStep + mapi);
						}
					}

					if (doreferencealign)
					{
						for (size_t nframe = 0; nframe < numframes; nframe++)
						{
							size_t uid = uidsstripe[nframe];
							if (samplesInRecurrentStep > 1)
								labels(uid, (nframe + validframes[mapi])*samplesInRecurrentStep + mapi) = 1.0;
							else
								labels(uid, ts + nframe) = 1.0;
						}
					}
					if (samplesInRecurrentStep > 1)
						validframes[mapi] += numframes;
					fprintf(stderr, "dengamma value %f\n", denavlogp);
					/*if (samplesInRecurrentStep == 1)
					ts += numframes;
					else
					ts = (i+1) * mbsize;*/
					ts += numframes;
				}

				/*-----------------------------------------------------------------------------------------*/
				//convert from Microsoft::MSR::CNTK::Matrix to  msra::math::ssematrixbase
				size_t numrows = prob.GetNumRows();
				size_t numcols = prob.GetNumCols();

				m_deviceid = prob.GetDeviceId();

				Microsoft::MSR::CNTK::Matrix<ElemType> oneUttCTCScore(m_deviceid);
				Microsoft::MSR::CNTK::Matrix<ElemType> oneUttLogsoftmax(m_deviceid);
				Microsoft::MSR::CNTK::Matrix<ElemType> alpha(m_deviceid);
				Microsoft::MSR::CNTK::Matrix<ElemType> beta(m_deviceid);				

				ElemType finalscore = 0;


				std::vector<size_t> phoneseq;
				size_t blankid = numrows - 1;
				//copy prob to pred
				if (samplesInRecurrentStep == 1)
				{
					//oneUttLogsoftmax.SetValue(prob);
					phoneseq.push_back(65535);
					for (size_t i = 0; i < uids.size(); i++)
					{
						if (uids[i] != 65535 && uids[i] != 0 && uids[i] != 1 && uids[i] != 2 && uids[i] != 34)
						{
							phoneseq.push_back(blankid);
							phoneseq.push_back(uids[i]);

						}
					}
					phoneseq.push_back(blankid);
					phoneseq.push_back(65535);

					/*size_t phoneseqsize = phoneseq.size();
					if (phoneseqsize > gpuphoneseqsize)
					{
					gpuphoneseqsize = phoneseqsize;
					CUDA_CALL(cudaFree(gpuphoneseq));
					CUDA_CALL(cudaMalloc((void **)&gpuphoneseq, gpuphoneseqsize*sizeof(size_t)));
					}

					CUDA_CALL(cudaMemcpy(gpuphoneseq, phoneseq.data(), phoneseq.size()*sizeof(size_t), cudaMemcpyHostToDevice));*/
					//oneUttLogsoftmax.Print("prob");
					functionValues.SetValue(0.0);
					functionValues.AssignCTCScore(prob, alpha, beta, phoneseq, finalscore, numcols, true);
					//if (numcols == 706)
					{
						/*prob.Print("prob");
						alpha.Print("alpha");
						beta.Print("beta");
						functionValues.Print("gamma");*/
					}

					//oneUttCTCScore.AssignAbsOf()
					finalscore = -1 * beta.Get00Element();
					fprintf(stderr, "totalscore %f\n", finalscore / numcols);

				}

				else
				{
					size_t ts_uid = 0;
					for (size_t i = 0; i < samplesInRecurrentStep; i++)
					{
						size_t numframes = validframes[i];
						if (oneUttLogsoftmax.GetNumCols() < numframes)
						{
							oneUttLogsoftmax.Resize(numrows, numframes);
							oneUttCTCScore.Resize(numrows, numframes);
						}

						for (size_t t = 0; t < numframes; t++)
						{
							oneUttLogsoftmax.SetColumn(prob.ColumnSlice(t*samplesInRecurrentStep + i, 1), t);
						}

						array_ref<size_t> uidsstripe(&uids[ts_uid], numframes);
						phoneseq.clear();
						phoneseq.push_back(65535);
						for (size_t p = 0; p < uidsstripe.size(); p++)
						{
							//if (uidsstripe[p] != 65535)
							if (uidsstripe[p] != 65535 && uidsstripe[p] != 0 && uidsstripe[p] != 1 && uidsstripe[p] != 2 && uidsstripe[p] != 34)
							{
								phoneseq.push_back(blankid);
								phoneseq.push_back(uidsstripe[p]);
							}
						}
						phoneseq.push_back(blankid);
						phoneseq.push_back(65535);


						oneUttCTCScore.SetValue(0.0);
						oneUttCTCScore.AssignCTCScore(oneUttLogsoftmax, alpha, beta, phoneseq, finalscore, numframes, true);

						/*oneUttLogsoftmax.Print("prob");
						alpha.Print("alpha");
						beta.Print("beta");
						oneUttCTCScore.Print("gamma");*/
						finalscore += -1 * beta.Get00Element();
						ElemType ftemp = -1 * beta.Get00Element() / numframes;
						fprintf(stderr, "totalscore: %f\n", ftemp);
						if (ftemp > 10000.000)
						{
							oneUttLogsoftmax.Print("prob");
							alpha.Print("alpha");
							beta.Print("beta");
							oneUttCTCScore.Print("gamma");
						}
						for (size_t t = 0; t < numframes; t++)
						{
							functionValues.SetColumn(oneUttCTCScore.ColumnSlice(t, 1), t*samplesInRecurrentStep + i);
						}
						ts_uid += numframes;
					}
				}

        protected:
            msra::asr::simplesenonehmm m_hset;
            msra::lattices::lattice::parallelstate parallellattice;
            msra::lattices::mbrclassdefinition mbrclassdef = msra::lattices::senone;    // defines the unit for minimum bayesian risk
            bool initialmark;
            msra::dbn::matrix dengammas;
            msra::dbn::matrix pred;
            int m_deviceid;  //-1: cpu
            size_t m_maxframenum;
            float lmf ; // Note that 9 was best for Fisher  --these should best be configurable
            float wp ;
            float amf;
            msra::dbn::matrix gammasbuffer;
            vector<size_t> boundary;
            float boostmmifactor;
            bool seqsMBRmode;
            
			Microsoft::MSR::CNTK::Matrix<ElemType> tempmatrix;
            //vector<size_t> uids;

        private:

        };

        

       
    };
};